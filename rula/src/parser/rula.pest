// Everything starts here
rula = { SOI ~ COMMENT? ~ program ~ COMMENT? ~ EOI }

// Program endpoing
program = { ( stmt )* }

// Statement includes {let, braced statement, expression}
stmt = { let_stmt | brace_stmt | expr }

// Variable assignment
let_stmt = { ^"let" ~ ( ident_typed | ident ) ~ "=" ~ ( compr | expr ) ~ ";" }

// Expressions (shoud ident be in expression?)
expr = { ( import_expr
           | fn_def_expr
           | if_expr
           | for_expr
           | while_expr
           | term
           | literals
            ) }

// Import statement (e.g. import hello::world; import hello::world::{yo, ya};)
import_expr = { ^"import" ~ ident ~ ( "::" ~ ident )* ~ ( "::" ~ "{" ~ ident_list ~ "}")?  ~ !"::" ~ ";" }

// If expression (e.g. if (block > 0) {expreesion;};)
if_expr = { ^"if" ~ paren_expr ~ brace_stmt ~ ( else_if_expr )* ~ else_expr? }
else_if_expr = { ^"else" ~ ^"if" ~ paren_expr ~ brace_stmt }
else_expr = { ^"else" ~ brace_stmt }

// For expression (e.g. for (i) in [0..10]{})
for_expr = { ^"for" ~ "(" ~ pattern ~")"~ "in" ~ expr ~ brace_stmt }
pattern = _{ ident_list }

// While expression (e.g. while(True){doforever;})
while_expr = { ^"while" ~ paren_expr ~ brace_stmt }

 // Function definition expression (e.g. fn hello(){world})
fn_def_expr = { ^"fn" ~ arguments ~ brace_stmt }
arguments = { "(" ~ ( ident_typed? ~ ( "," ~ ident_typed )* ) ~ ")" }

// Term expr without any operator recedence
term = { inner_term ~ ( op ~ inner_term )* }
inner_term = _{ number | "(" ~ term ~ ")" }

// A set of arithmetic operations for tems
op = _{ ( plus | minus | asterisk | slash | caret ) }
plus = { "+" }
minus = { "-" }
asterisk = { "*" }
slash = { "/" }
caret = { "^" }

// Comparison (no chain comparison allowed)
compr = { expr ~ comp_op ~ expr }
comp_op = { "<" | ">" | "=<" | ">=" | "==" | "!="}

// expression with parenthesis
paren_expr = _{ "(" ~ ( compr | expr )  ~ ")" }

// Statement srrounded by curly brace
brace_stmt = _{ "{" ~ stmt ~ "}" }

// Identifiers
ident_list = { ( ident | ident_typed ) ~ ( "," ~ ( ident | ident_typed ) )* }
ident_typed = { ident ~ ( ":" ~ typedef_lit ) }
ident = @{ ASCII_ALPHA ~ ( ASCII_ALPHA | ASCII_DIGIT | "_" )* }

// Literals (ref: https://pest.rs/book/examples/rust/literals.html)
literals = { ( bool | string | ident | binary | hex | unicord ) }

// Boolean literal
bool = { true_lit | false_lit }
true_lit  = @{ "true" }
false_lit = @{ "false" }

// number literal (int, float)
number = @{ int ~ ( "." ~ ASCII_DIGIT* )? ~ ( ^"e" ~ int )? }

// Integer literal (10, 1000, 10e10, -10, -10e-10 etc)
// This will allow white space between digits (FIXME)
int = { "-"? ~ ASCII_DIGIT+ ~ ( "e" ~ ( "+" | "-" )? ~ ASCII_DIGIT+ )? ~!( ASCII_ALPHA ) } 
// Binary literals (e.g. b101100)
binary = {"b" ~ ( "0" | "1" )*}

// Hex digit literals (e.g. x109ab2)
hex = {"x" ~ ( '0'..'9' | "a" | "b" | "c" | "d" | "e" )*}

// Unicord
unicord = { "u" ~ hex }

// String literals (escape should be added later)
string = _{ "\"" ~ ( raw_string )* ~ "\"" }
raw_string = { (!( "\\" | "\"" ) ~ ANY )+ }

// Type definition literal
typedef_lit = { ( integer_type
                  | unsigned_integer_type
                  | float_type
                  | complex_type
                  | boolean_type
                  | string_type
                  | qubit_type
) }
integer_type = { ( "i32" | "i64" ) }
unsigned_integer_type = { ( "u32" | "u64" ) }
float_type = { ( "f32" | "f64" ) }
complex_type = { ( "c64" | "c128" ) }
boolean_type = { "bool" }
string_type = { "str" }
qubit_type = { "qubit" }
 
COMMENT = _{ ( "/*" ~ ( !"*/" ~ ANY )* ~ "*/" | "//" ~ ( !"\n" ~ ANY )* ~ ( "\n" | EOI ) ) }
WHITESPACE = _{ ( " " | "\n" ) }