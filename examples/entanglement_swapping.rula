import std::qubit::free;
import std::time::time;
import std::message::{Message, get_message};
import std::result::Result;
import std::operation::bsm;

// automatic assignment for qnic interfaces
#interface: {qn0, qn1} => qnall;

// This can also be defined by toml file
// CONFIG includes node specific variables
//CONFIG = {
//    num_node: 5,
//    distance: [0, 1, 1, 1, 0],
//    target: initiator,
//}

//rule default<qn0>() {
//	cond{
//        time() - qubit.initiated() > 0.0003,
//	} => act{
//		free(q);
//	}
//}

rule swapping<qn0, qn1>(distance) {
    cond {
        watch {
            let q1 = qn0.request_resource(1, qn0.get_partner_by_hop(distance));
            let q2 = qn1.request_resource(1, qn1.get_partner_by_hop(distance));
        }
        distance > 0,
        q1.ready(),
        q2.ready(),
    } => act{
        let message = Message("swapping", qn0, qn0.get_partner_by_hop(distance));
        let result = Result(q1);
        // store two results at the same time?
        result.add_tag("meas_result").add_result(bsm(q1, q2))
        message.append_body(result)
        send(message)
    }
}

// Fix here to qnall
rule pauli_correction<qn0>(distance){
    cond {
        watch{
            let message = qn0.get_message(qn0.get_partner_by_hop);
        }    
        message.kind == "swapping",
    } => act{
        let target_qubit = qn0.get_qubit_by_partner(message.src, message.body.result.qubit_address);
        match result: message.result.meas_result{
            (result == "00") => {},
            (result == "01") => {target_qubit.z()},
            (result == "10") => {target_qubit.x()},
            (result == "11") => {target_qubit.z(), target_qubit.x()},
            finally => {free(target_qubit)}
        }
    }
}


ruleset(CONFIG) entanglement_swapping{
    default: default()
    swapping(CONFIG.distance)
    pauli_correction(CONFIG.distance)
}