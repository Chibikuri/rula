import std::time::time;
import std::message::Message;
import std::result::Result;
import std::operation::bsm;

// automatic assignment for qnic interfaces
#interface: {qn0, qn1} => qnall;

// This can also be defined by toml file
// CONFIG includes node specific variables
#config: (5){
    distance: vec[u64],
} => CONFIG;

//rule default<qn0>() {
//	cond{
//        time() - qubit.initiated() > 0.0003,
//	} => act{
//		free(q);
//	}
//}

rule swapping<qn0, qn1>(distance: u64) {
    cond {
        watch {
            let q1: Qubit = qn0.request_resource(1, qn0.get_partner_by_hop(distance));
            let q2: Qubit = qn1.request_resource(1, qn1.get_partner_by_hop(distance));
        }
        distance > 0,
        q1.ready(),
        q2.ready(),
    } => act{
        let message = Message("swapping", qn0.address, qn0.get_partner_by_hop(distance));
        let result = Result(q1);
        // store two results at the same time?
        result.add_tag("meas_result").add_result(bsm(q1, q2))
        message.append_body(result)
        send(message)
    }
}

// Fix here to qnall
rule pauli_correction<qn0>(distance: u64){
    cond {
        watch{
            let message = qn0.get_message(qn0.get_partner_by_hop(distance));
        }    
        message.kind == "swapping",
    } => act{
        let target_qubit: Qubit = qn0.get_qubit_by_partner(message.src, message.body.result.qubit_address);
        // Want to remove this Result future
        match result: message.body.result.get_result(){
            "00" => {},
            "01" => {target_qubit.z()},
            "10" => {target_qubit.x()},
            "11" => {target_qubit.z(), target_qubit.x()},
            finally => {free(target_qubit)}
        }
    }
}


ruleset(CONFIG) entanglement_swapping{
    default: default()
    swapping(CONFIG.distance)
    pauli_correction(CONFIG.distance)
}