import std::time::time;
import std::message::Message;
import std::result::Result;
import std::operation::bsm;

#interface: {qn0, qn1} => qnall;

#config: (5){
    distance: vec[u_int],
} => CONFIG;


rule swapping<qn0, qn1>(distance: u_int) {
    cond {
        watch {
            let q1: qubit = qn0.request_resource(1, qn0.get_partner_by_hop(distance))
            let q2: qubit = qn1.request_resource(1, qn1.get_partner_by_hop(distance))
        }
        distance > 0,
        q1.ready(),
        q2.ready(),
    } => act{
        let message = Message("swapping", qn0.address, qn0.get_partner_by_hop(distance))
        let result = Result(q1)
        // store two results at the same time?
        result.add_tag("meas_result").add_result(bsm(q1, q2))
        message.append_body(result)
        send(message)
    }
}

// Fix here to qnall
rule pauli_correction<qn0>(distance: u_int){
    cond {
        watch{
            let message = qn0.get_message(qn0.get_partner_by_hop(distance))
        }    
        message.kind == "swapping",
    } => act{
        let target_qubit: qubit = qn0.get_qubit_by_partner(message.src, message.body.result.qubit_address)
        // Want to remove this Result future
        match result: message.body.result.get_result(){
            "00" => {},
            "01" => {target_qubit.z()},
            "10" => {target_qubit.x()},
            "11" => {target_qubit.z(), target_qubit.x()},
            finally => {free(target_qubit)}
        }
    }
}


ruleset(CONFIG) entanglement_swapping{
    swapping(CONFIG.distance)
    pauli_correction(CONFIG.distance)
}