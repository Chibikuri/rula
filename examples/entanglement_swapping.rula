

// automatic assignment for qnic interfaces
#interface: {qn0, qn1} => qnall;
// This can also be defined by toml file
// CONF includes node specific variables
//#def: CONF = {
//    distance = [1, 1, 1, 1, 1],
//}

rule default<qn0>() {
	cond{
	} => act{
		free(q);
	}
}

rule swapping<qn0, qn1>(distance) {
    monitor:
        let q1 = qn0.get_free_qubit(1, qn0.get_partner_by_hop(distance));
        let q2 = qn1.get_free_qubit(1, qn1.get_partner_by_hop(distance));
    cond {
        // How to ensure these qubits have the proper partners?
        // -> This can be given by external parameter
        q1.ready(),
        q2.ready(),
    } => act{
        let message = Message(kind="swapping", src=qn0, dest=qn0.get_partner_by_hop(distance));
        result["qubit_address"] = q1.address;
        result["meas_result"] = bsm(q1, q2);
        message["body"] = result;
        send(message);
    }
}

rule pauli_correction<qnall>(){
    // Should this be qubit address?
    monitor:
        let message = get_message(#qnall);
    cond {
        message.kind == "swapping",
    } => act{
        // lookup qubit by partner address
        let qubit = lookup_qubit(message.src, message.body.qubit_address);
        let target_qubit = lookup_by_index(#qnall, qubit_index);
        match result: message.result.meas_result{
            (result == "00") => {},
            (result == "01") => {pauli_z(target_qubit)},
            (result == "10") => {pauli_x(target_qubit)},
            (result == "11") => {pauli_z(target_qubit), pauli_x(target_qubit)},
            finally => {free(target_qubit)}
        }
    }
}


ruleset(CONF) entanglement_swapping{
    default: default()
    swapping(CONF.distance);
    pauli_correction();
}