import std::time::time;
import std::message::Message;
import std::result::Result;

#interface: {qn0, qn1};

#config: (100){
    distance: vec[u_int],
} => CONFIG;


rule local_operation<qn0, qn1>(distance: u_int) {
	cond {
		watch {
			let q0 = qn0.request_resource(1, qn0.get_partner_by_hop(distance))
			let q1 = qn0.request_resource(1, qn0.get_partner_by_hop(distance))
		}
	q0.ready(),
	q1.ready(),
	q0.expected_fidelity() > 0.8,
	q0.expected_fidelity() < 0.95,
	} => act {
	let message = Message("purification", qn0.address, qn0.get_partner_by_hop(distance))
	q0.cx(q1)
	let result = Result(q1)
	result.add_result(q1.measure_z())
	message.append_body(result)
	send(message)
	return q0
	}
}

rule parity_check<qn0, qn1> (self_result: str, distance: u_int){
	cond {
		watch{
			let message = qn0.get_message(qn0.get_partner_by_hop(distance))
			}
			message.kind == "purification",
	} => act{
		let target_qubit = qn0.get_qubit_by_partner(message.src,
		message.body.result.qubit_address)
		if (message.body.result.get_output() == self_result){
			promote(target_qubit)
		} else {
			free(target_qubit)
		}
	}
}


ruleset(CONFIG) purification {
	let self_result = local_operation(CONFIG.distance)
	// FIXME, Right now, the argument name must be rule argument name.
	parity_check(self_result, CONFIG.distance)
}

