// This is entory point to generate code from AST
use super::error::RuLaCompileError;
use rula::parser::ast::*;
use std::collections::HashMap;
use std::error::Error;
use std::hash::Hash;
use std::marker::PhantomData;

pub type IResult<T> = std::result::Result<T, Box<dyn Error>>;

// generate corresponding rust code from ast
pub fn generate(ast_tree: Vec<AstNode>) -> RustProgram {
    let mut rula_program = RuLaProgram::new();
    for ast_node in ast_tree {
        match ast_node {
            AstNode::RuLa(rula) => {
                rula_program = RuLaProgram::from(generate_rula(rula).unwrap())
                // println!("hello{:#?}", rula);
            }
            AstNode::PlaceHolder => {
                // return Box::mew(Err(RuLaCompileError::RuLaGenerationError))
                // panic!("Value not properly set");
            }
        }
    }
    rula_program.gen_rust()
}

// trait generates rust code
pub trait GenRust {
    fn gen_rust(&self) -> RustProgram;
}

#[derive(Debug)]
pub struct RuLaProgram {
    pub program: Box<Option<RuLaProgram>>,
    // phantom: PhantomData<T>,
}

impl RuLaProgram {
    pub fn new() -> Self {
        RuLaProgram {
            program: Box::new(None),
            // phantom: PhantomData
        }
    }
    pub fn from(rula_program: Option<RuLaProgram>) -> Self {
        RuLaProgram {
            program: Box::new(rula_program),
            // phantom: PhantomData
        }
    }
}

impl GenRust for RuLaProgram {
    fn gen_rust(&self) -> RustProgram {
        RustProgram::new(None, String::from("// Autogenerated RuLa program"))
    }
}

// Do we need phantom here?
#[derive(Debug)]
pub struct RustProgram {
    pub metadata: Option<HashMap<String, String>>,
    pub program: String,
}

impl RustProgram {
    pub fn new(meta_data: Option<HashMap<String, String>>, program_str: String) -> Self {
        RustProgram {
            metadata: meta_data,
            program: program_str,
        }
    }

    pub fn from(meta_data: Option<HashMap<String, String>>, program_str: &str) -> Self {
        RustProgram {
            metadata: None,
            program: String::from(program_str),
        }
    }
}

fn generate_rula(rula: RuLa) -> IResult<Option<RuLaProgram>> {
    match *rula.rula {
        RuLaKind::Program(program) => {
            println!("program");
        }
        RuLaKind::Ignore => {
            println!("comment")
        }
        RuLaKind::Eoi => {
            println!("end of input")
        }
        RuLaKind::PlaceHolder => {
            println!("Should be value error")
        } // _ => unreachable!(),
    }
    let rula = RuLaProgram::new();
    Ok(Some(rula))
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_simple_generation() {
        let target_ast = vec![AstNode::RuLa(RuLa::place_holder())];
        let result = generate(target_ast);
        println!("Result{:#?}", result);
        // generate_file(result, String::from("./test.rs"))
    }
}
