rule local_operation<#rep>(distance: int) :-> Qubit {
    let partner: Repeater = #rep.hop(distance)
    cond {
        @q1: res(1, 0.8, partner, 0)
        @q2: res(1, 0.5, partner, 1)
    } => act {
        // do cx
        cx(q1, q2)
        // measure the target qubit
        let result: Result = measure(q2, "Z")
        meas(q2, result) -> partner
        set result as self_result
        promote q1 
    }
}

rule parity_check<#rep>(distance: int, promoted: Qubit) :-> Qubit? {
    let partner: Repeater = #rep.hop(distance)
    cond {
        @message: recv(partner)
    } => act {
        if(message.result == get self_result){
            // purification success
            promote promoted
        }else{
            // purification failed (This can be an expression)
            free(promoted)
        }
    }
}