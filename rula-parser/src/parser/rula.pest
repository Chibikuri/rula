rula = { SOI ~ COMMENT? ~ program ~ COMMENT? ~ EOI }

program = { repeaters? ~ ( import_expr | rule_expr | ruleset_expr )* }

stmt = { let_stmt | expr }

repeaters = {"#repeaters: vec[Repeater]"}

let_stmt = { ^"let" ~ ( ident_typed | "(" ~ ident_typed ~ ("," ~ ident_typed)* ~ ")" ) ~ "=" ~ expr}

expr = {
  // named
  import_expr |
  ruleset_expr |
  rule_expr |
  if_expr | 
  for_expr|
  match_expr | 
  return_expr | 
  // non-named
  send_expr |
  fn_call_expr |
  rule_call_expr| 
  // comparison must be higher precedence
  comp_expr |
  term_expr | 
  variable_call_expr |
  literal_expr
}

import_expr = { ^"import" ~ ident ~ ( "::" ~ ident )* ~ ( "::" ~ "{" ~ ident_list ~ "}")?  ~ !"::" }

match_expr = {^"match" ~ expr ~ "{" ~ (match_arm ~  ",")* ~ (^"otherwise" ~ "=>" ~ match_action)? ~ "}"}
match_arm = { match_condition ~ "=>" ~ match_action }
match_condition = {satisfiable}
satisfiable = { literal_expr }
match_action = {"{" ~ expr? ~ ("," ~ expr)* ~ "}"}

return_expr = {^"return" ~ expr?}

// If expression (e.g. if (block > 0) {expreesion;};)
if_expr = { ^"if" ~ "(" ~ expr ~ ")" ~ "{" ~ (stmt)* ~ "}" ~ ( else_if_expr )* ~ else_expr? }
else_if_expr = { ^"else" ~ ^"if" ~ "(" ~ expr ~ ")" ~ "{" ~ (stmt)* ~ "}" }
else_expr = { ^"else" ~ "{" ~ (stmt)* ~ "}"}

for_expr = { ^"for" ~ ( ident | for_multi_block ) ~ "in" ~ for_generator ~ "{" ~ (stmt)* ~ "}"}
for_multi_block = _{"(" ~ ident_list ~ ")"}
for_generator = _{ series | expr }
series = { int ~ ".." ~ expr }

send_expr = { fn_call_expr ~ "->" ~ expr }

// term_expr = { inner_term ~ ( op ~ inner_term )* }
// inner_term = _{ number | "(" ~ term_expr ~ ")" }
// currently, term expression is very limited 
term_expr = { terms ~ op ~ terms }
terms = { variable_call_expr | fn_call_expr | literal_expr }

// A set of arithmetic operations for tems
op = _{ ( plus | minus | asterisk | slash | percent | caret ) }
plus = { "+" }
minus = { "-" }
asterisk = { "*" }
slash = { "/" }
percent = {"%"}
caret = { "^" }

// Comparison (no chain comparison allowed)
comp_expr = { comparable ~ comp_op ~ comparable }
comparable = { variable_call_expr | fn_call_expr | term_expr | literal_expr }
comp_op = { "<" | ">" | "=<" | ">=" | "==" | "!=" }

// Rule expression to define RuLa rule
ruleset_expr = {^"ruleset" ~ ident ~ "{" ~ (stmt)* ~ "}" }

rule_expr = { ^"rule" ~ ident ~ "<" ~ repeater_ident ~ ">"~ argument_def ~ (":->" ~ ret_type_annotation)? ~ "{" ~ rule_contents ~ "}" }
ret_type_annotation = { typedef_lit ~ maybe? | "(" ~ (typedef_lit ~ maybe?) ~ ("," ~ typedef_lit ~ maybe?)* ~ ")"}
maybe = {"?"}
argument_def = { "(" ~ ( ( ident_typed | ident )? ~ ( "," ~ ( ident_typed | ident ) )* ) ~ ")" }
rule_contents = { ( let_stmt )* ~ cond_expr ~ "=>" ~ act_expr ~ ( stmt )* }

cond_expr = {^"cond" ~ "{"~ (cond_clauses)*  ~ "}"}
cond_clauses = _{ let_stmt | fn_call_expr | comp_expr }

act_expr = { ^"act" ~ "{" ~ (stmt)* ~ "}"}

variable_call_expr = { callable ~ "." ~ callable ~ ("." ~ callable)*}
callable = { fn_call_expr | repeater_ident | ident }

rule_call_expr = { ident ~ "<" ~ expr ~ ">" ~ "(" ~ fn_call_args? ~ ("," ~ fn_call_args)* ~ ")"}

fn_call_expr = { (repeater_ident | ident) ~ "(" ~ fn_call_args? ~ ("," ~ fn_call_args)* ~ ")" }
fn_call_args = _{ fn_call_expr | variable_call_expr | term_expr | literal_expr }

repeater_ident = { "#" ~ ident}

ident_list = { ( ident | ident_typed ) ~ ( "," ~ ( ident | ident_typed ) )* }
ident_typed = { ident ~ ":" ~ typedef_lit }
ident = @{ ASCII_ALPHA~ ( ASCII_ALPHA | ASCII_DIGIT | "_" )* }

literal_expr = { ( bool | string | ident | number | binary | hex | unicord ) }
literal_list = { literal_expr ~ ("," ~ literal_expr)* }

bool = { true_lit | false_lit }
true_lit  = @{ "true" }
false_lit = @{ "false" }

// number literal (int, float)
// "-some_number" is also fine
number = @{ ("+" | "-")? ~ ( int | ident ) ~ ( "." ~ ASCII_DIGIT* )? ~ ( ^"e" ~ int )? }

// Integer literal (10, 1000, 10e10, -10, -10e-10 etc)
// This will allow white space between digits (FIXME)
int = { "-"? ~ ASCII_DIGIT+ ~ ( "e" ~ ( "+" | "-" )? ~ ASCII_DIGIT+ )? ~!( ASCII_ALPHA ) } 
// Binary literals (e.g. b101100)
binary = { "0b" ~ bin_num}
bin_num = {( "0" | "1" )*}

// Hex digit literals (e.g. x109ab2)
// Should this be case sensitive?
hex = { "0x" ~ hex_num}
hex_num = {( ASCII_DIGIT | "a" | "b" | "c" | "d" | "e" | "f" | "A" | "B" | "C" | "D" | "E" | "F" )*}

// Unicord
unicord = { "0u" ~  hex_num }

// String literals (escape should be added later)
string = _{ "\"" ~ ( raw_string )* ~ "\"" }
raw_string = { (!( "\\" | "\"" ) ~ ANY )+ }


// Type definition literal
typedef_lit = { ( vector_type
                  | integer_type
                  | unsigned_integer_type
                  | float_type
                  | boolean_type
                  | string_type
                  | qubit_type
                  | repeater_type
                  | message_type
) }

vector_type = {"vec" ~ "[" ~ typedef_lit ~ "]"}
integer_type = { "int" }
unsigned_integer_type = { "u_int" }
float_type = { "float" }
boolean_type = { "bool" }
string_type = { "str" }
qubit_type = { "qubit" }
repeater_type = { "Repeater" }
message_type = { "Message" }

COMMENT = _{ ( "/*" ~ ( !"*/" ~ ANY )* ~ "*/" | "//" ~ ( !"\n" ~ ANY )* ~ ( "\n" | EOI ) ) }
WHITESPACE = _{ ( " " | "\n" | "\t") }