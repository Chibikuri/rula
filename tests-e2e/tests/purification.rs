// This is autogenerated Rust program
use crate::rula_std::ruleset::ruleset::*;
use rula_lib as rula_std;
use rula_std::ruleset::action::v2::ActionClauses;
use std::cell::RefCell;
use std::fs;
use std::fs::File;
use std::io::Write;
use std::rc::Rc;
#[allow(non_snake_case)]
#[allow(non_camel_case_types)]
#[allow(unused_doc_comments)]
#[allow(dead_code)]
#[allow(warnings, unused)]
mod rula {
    use super::*;
    use once_cell::sync::OnceCell;
    use rula_std::message::*;
    use rula_std::operation::*;
    use rula_std::prelude::*;
    use rula_std::qnic::*;
    use rula_std::qubit::*;
    use rula_std::result::*;
    use rula_std::ruleset::action::v2::ActionClauses as ActionClausesV2;
    use rula_std::ruleset::condition::v1::ConditionClauses;
    use rula_std::ruleset::condition::v1::*;
    use rula_std::ruleset::ruleset::*;
    use rula_std::RuleVec;
    use serde::{Deserialize, Serialize};
    use std::cell::RefCell;
    use std::collections::{HashMap, HashSet};
    use std::iter::FromIterator;
    use std::rc::Rc;
    use tokio::sync::Mutex as TokioMutex;
    use tokio::time::{sleep, Duration};
    pub static INTERFACES: OnceCell<TokioMutex<HashMap<String, QnicInterface>>> = OnceCell::new();
    pub enum UnreadyRules {
        unready_local_operation(unready_local_operation),
        unready_parity_check(unready_parity_check),
    }
    impl UnreadyRules {
        pub fn check_arg_resolved(&self) -> Option<ReadyRules> {
            match &self {
                UnreadyRules::unready_local_operation(unready_local_operation) => {
                    unready_local_operation.argument_resolved()
                }
                UnreadyRules::unready_parity_check(unready_parity_check) => {
                    unready_parity_check.argument_resolved()
                }
                _ => {
                    panic!("No rule name found");
                }
            }
        }
        pub fn arg_list(&self) -> Vec<String> {
            match &self {
                UnreadyRules::unready_local_operation(unready_local_operation) => {
                    unready_local_operation.arg_list()
                }
                UnreadyRules::unready_parity_check(unready_parity_check) => {
                    unready_parity_check.arg_list()
                }
                _ => {
                    panic!("No rule name found");
                }
            }
        }
        pub fn resolve_argument(&mut self, arg_name: &str, argument: Argument) {
            match self {
                UnreadyRules::unready_local_operation(unready_local_operation) => {
                    unready_local_operation.resolve_argument(arg_name, argument);
                }
                UnreadyRules::unready_parity_check(unready_parity_check) => {
                    unready_parity_check.resolve_argument(arg_name, argument);
                }
                _ => {
                    panic!("No rule name found");
                }
            }
        }
        pub fn gen_ruleset(&mut self, ruleset: &mut RuleSet<ActionClausesV2>) {
            match self {
                UnreadyRules::unready_local_operation(unready_local_operation) => {
                    unready_local_operation.gen_ruleset(ruleset);
                }
                UnreadyRules::unready_parity_check(unready_parity_check) => {
                    unready_parity_check.gen_ruleset(ruleset);
                }
                _ => {
                    panic!("No rule name found")
                }
            }
        }
    }
    pub enum ReadyRules {
        local_operation(local_operation),
        parity_check(parity_check),
    }
    use rula_std::message::Message;
    use rula_std::result::Result;
    use rula_std::time::time;
    pub async fn initialize_interface() {
        assert!(INTERFACES.get().is_none());
        let initialize_interface = || TokioMutex::new(HashMap::new());
        INTERFACES.get_or_init(initialize_interface);
        let interface_list = INTERFACES.get().expect("Failed to get interface");
        for (index, interface_name) in vec!["qn0", "qn1", ""].iter().enumerate() {
            let mock_qnic =
                QnicInterface::generate_mock_interface(index as u32, interface_name, 10);
            interface_list
                .lock()
                .await
                .insert(interface_name.to_string(), mock_qnic);
        }
    }
    pub fn initialize_static_interface(__num_nodes: u64) -> __StaticInterfaceList {
        let mut __static_interface_list = __StaticInterfaceList::new();
        __static_interface_list.__update_num_node(__num_nodes);
        for _ in 0..__num_nodes {
            let mut __static_interface = __StaticInterface::new();
            for (index, i_name) in vec!["qn0", "qn1", ""].iter().enumerate() {
                __static_interface.__add_interface_name(i_name);
                let qnic_interface =
                    QnicInterface::generate_mock_interface(index as u32, i_name, 10);
                __static_interface.__add_interface(i_name, qnic_interface);
            }
            __static_interface_list.__add_static_interface(__static_interface);
        }
        __static_interface_list.__check();
        __static_interface_list
    }
    type NodeNumber = u64;
    #[derive(Debug, Serialize, Deserialize)]
    pub struct __StaticInterfaceList {
        pub num_nodes: u64,
        pub __static_interfaces: HashMap<NodeNumber, __StaticInterface>,
        index: u64,
    }
    impl __StaticInterfaceList {
        pub fn new() -> Self {
            __StaticInterfaceList {
                num_nodes: 0,
                __static_interfaces: HashMap::new(),
                index: 0,
            }
        }
        pub fn __add_static_interface(&mut self, __static_interface: __StaticInterface) {
            self.__static_interfaces
                .insert(self.index, __static_interface);
            self.index += 1;
        }
        pub fn __get_interface(&self, index: NodeNumber) -> __StaticInterface {
            self.__static_interfaces
                .get(&index)
                .expect("No interface found")
                .clone()
        }
        pub fn __update_num_node(&mut self, num_nodes: u64) {
            self.num_nodes = num_nodes;
        }
        pub fn __check(&self) {
            if self.__static_interfaces.len() != self.num_nodes as usize {
                panic!("The qnics are not properly registered")
            }
        }
    }
    #[derive(Debug, Serialize, Deserialize, Clone)]
    pub struct __StaticInterface {
        pub interface_names: HashSet<String>,
        pub interfaces: HashMap<String, QnicInterface>,
    }
    impl __StaticInterface {
        pub fn new() -> Self {
            __StaticInterface {
                interface_names: HashSet::new(),
                interfaces: HashMap::new(),
            }
        }
        pub fn __add_interface_name(&mut self, value: &str) {
            if !self.interface_names.contains(value) {
                self.interface_names.insert(value.to_string());
            } else {
                panic!("Interface name duplication {}", value);
            }
        }
        pub fn __add_interface(&mut self, name: &str, qnic: QnicInterface) {
            if self.interface_names.contains(name) {
                self.interfaces.insert(name.to_string(), qnic);
            } else {
                panic!("No interface found {}", name);
            }
        }
        pub fn __get_interface(&self, interface_name: &str) -> QnicInterface {
            self.interfaces
                .get(interface_name)
                .expect("Failed to get interface")
                .clone()
        }
    }
    #[derive(Debug, Serialize, Deserialize)]
    pub struct CONFIG {
        pub distance: Vec<u64>,
        __names: Option<HashSet<String>>,
        __num_nodes: Option<u64>,
    }
    impl CONFIG {
        pub fn __finalize(&mut self) {
            let keys = vec!["distance".to_string()];
            self.__names = Some(HashSet::from_iter(keys.iter().cloned()));
            self.__num_nodes = Some(100)
        }
        fn __key_exist(&self, value: &str) -> bool {
            self.__names
                .as_ref()
                .expect("Unable to find config item names")
                .contains(value)
        }
        pub fn __get_as_arg(&self, config_val: &str, index: Option<usize>) -> Option<Argument> {
            if self.__key_exist(config_val) {
                match config_val {
                    "distance" => {
                        let mut arg = Argument::init();
                        match index {
                            Some(ind) => {
                                arg.add_argument(
                                    ArgVal::UnsignedInteger64(self.distance[ind].clone()),
                                    LibTypeHint::UnsignedInteger64,
                                );
                                Some(arg)
                            }
                            None => {
                                arg.add_argument(
                                    ArgVal::U64Vector(self.distance.clone()),
                                    LibTypeHint::Vector(Box::new(LibTypeHint::UnsignedInteger64)),
                                );
                                Some(arg)
                            }
                        }
                    }
                    _ => {
                        panic!("This should not happen")
                    }
                }
            } else {
                None
            }
        }
    }
    pub struct local_operation {
        name: String,
        interface_names: Vec<String>,
        arguments: HashMap<String, Argument>,
        parent_ruleset: Rc<RefCell<RuleSetExec>>,
    }
    pub struct unready_local_operation {
        name: String,
        interface_names: Vec<String>,
        static_interfaces: __StaticInterface,
        arguments: HashMap<String, Argument>,
        parent_ruleset: Rc<RefCell<RuleSetExec>>,
    }
    impl unready_local_operation {
        pub fn new(
            __static_interface: __StaticInterface,
            parent_ruleset: Rc<RefCell<RuleSetExec>>,
        ) -> unready_local_operation {
            let mut empty_argument = HashMap::new();
            let arg = Argument::init();
            empty_argument.insert("distance".to_string(), arg);
            unready_local_operation {
                name: String::from("local_operation"),
                interface_names: vec!["qn1".to_string(), "qn0".to_string()],
                static_interfaces: __static_interface,
                arguments: empty_argument,
                parent_ruleset: parent_ruleset,
            }
        }
        pub fn argument_resolved(&self) -> Option<ReadyRules> {
            for (_, arg) in &self.arguments {
                if !arg.resolved() {
                    return None;
                }
            }
            Some(ReadyRules::local_operation(local_operation {
                name: self.name.clone(),
                interface_names: self.interface_names.clone(),
                arguments: self.arguments.clone(),
                parent_ruleset: self.parent_ruleset.clone(),
            }))
        }
        pub fn arg_exist(&self, arg_name: &str) -> bool {
            self.arguments.contains_key(arg_name)
        }
        pub fn resolve_argument(&mut self, arg_name: &str, new_arg: Argument) {
            let mut arg = self
                .arguments
                .get_mut(arg_name)
                .expect("Unable to find argument");
            *arg = new_arg
        }
        pub fn arg_list(&self) -> Vec<String> {
            let mut arg_vec = vec![];
            for (arg, _) in &self.arguments {
                arg_vec.push(arg.clone());
            }
            arg_vec
        }
        pub fn register_return_val(&mut self, rule_name: &str, argument: Argument) {
            self.parent_ruleset
                .borrow_mut()
                .__register_return_val(rule_name, argument);
        }
        #[doc = "No execution, but gen ruleset"]
        fn static_ruleset_gen(&mut self) -> Stage<ActionClausesV2> {
            let mut stage = Stage::<ActionClausesV2>::new();
            #[doc = "Initialy, this starts just a single rule, but if there is match or if expression, this should be expanded."]
            let rules = Rc::new(RefCell::new(vec![RefCell::new(
                Rule::<ActionClausesV2>::new("local_operation"),
            )]));
            let mut q0 = self
                .static_interfaces
                .__get_interface("qn0")
                .__static__request_resource(
                    Rc::clone(&rules),
                    1.clone(),
                    self.static_interfaces
                        .__get_interface("qn0")
                        .__static__get_partner_by_hop(
                            Rc::clone(&rules),
                            self.arguments
                                .get("distance")
                                .unwrap()
                                .eval_unsigned_int64()
                                .clone(),
                        )
                        .clone(),
                );
            let mut q1 = self
                .static_interfaces
                .__get_interface("qn0")
                .__static__request_resource(
                    Rc::clone(&rules),
                    1.clone(),
                    self.static_interfaces
                        .__get_interface("qn0")
                        .__static__get_partner_by_hop(
                            Rc::clone(&rules),
                            self.arguments
                                .get("distance")
                                .unwrap()
                                .eval_unsigned_int64()
                                .clone(),
                        )
                        .clone(),
                );
            let _ = q0.__static__ready(Rc::clone(&rules));
            let _ = q1.__static__ready(Rc::clone(&rules));
            let _ = __static__comp(
                q0.__static__expected_fidelity(Rc::clone(&rules)),
                __CmpOp::Gt,
                0.8,
                false,
                Rc::clone(&rules),
            );
            let _ = __static__comp(
                q0.__static__expected_fidelity(Rc::clone(&rules)),
                __CmpOp::Lt,
                0.95,
                false,
                Rc::clone(&rules),
            );
            let mut message = __static__Message(
                Rc::clone(&rules),
                "purification".to_string().clone(),
                self.static_interfaces
                    .__get_interface("qn0")
                    .address
                    .clone(),
                self.static_interfaces
                    .__get_interface("qn0")
                    .__static__get_partner_by_hop(
                        Rc::clone(&rules),
                        self.arguments
                            .get("distance")
                            .unwrap()
                            .eval_unsigned_int64()
                            .clone(),
                    )
                    .clone(),
            );
            q0.__static__cx(Rc::clone(&rules), q1.clone());
            let mut result = __static__Result(Rc::clone(&rules), q1.clone());
            result.__static__add_result(
                Rc::clone(&rules),
                q1.__static__measure_z(Rc::clone(&rules)).clone(),
            );
            message.__static__append_body(Rc::clone(&rules), result.clone());
            __static__send(Rc::clone(&rules), message.clone());
            self.parent_ruleset
                .borrow_mut()
                .__register_return_val(&self.name, q0);
            for rule in &*rules.borrow() {
                stage.add_rule(rule.borrow().clone());
            }
            stage
        }
        fn gen_ruleset(&mut self, ruleset: &mut RuleSet<ActionClausesV2>) {
            let stage = self.static_ruleset_gen();
            ruleset.add_stage(stage);
        }
    }
    impl local_operation {
        async fn condition(&self) -> bool {
            let interface = INTERFACES
                .get()
                .expect("Unable to get interface table")
                .lock()
                .await;
            let mut q0 = interface
                .get("qn0")
                .expect("unable to get interface")
                .request_resource(
                    &1,
                    &interface
                        .get("qn0")
                        .expect("unable to get interface")
                        .get_partner_by_hop(
                            &self
                                .arguments
                                .get("distance")
                                .unwrap()
                                .eval_unsigned_int64(),
                        )
                        .await,
                )
                .await;
            let mut q1 = interface
                .get("qn0")
                .expect("unable to get interface")
                .request_resource(
                    &1,
                    &interface
                        .get("qn0")
                        .expect("unable to get interface")
                        .get_partner_by_hop(
                            &self
                                .arguments
                                .get("distance")
                                .unwrap()
                                .eval_unsigned_int64(),
                        )
                        .await,
                )
                .await;
            if q0.ready().await
                && q1.ready().await
                && __comp(q0.expected_fidelity().await, __CmpOp::Gt, 0.8)
                && __comp(q0.expected_fidelity().await, __CmpOp::Lt, 0.95)
            {
                (|| async {
                    let mut message = Message(
                        &"purification".to_string(),
                        &interface
                            .get("qn0")
                            .expect("unable to get interface")
                            .address,
                        &interface
                            .get("qn0")
                            .expect("unable to get interface")
                            .get_partner_by_hop(
                                &self
                                    .arguments
                                    .get("distance")
                                    .unwrap()
                                    .eval_unsigned_int64(),
                            )
                            .await,
                    );
                    q0.cx(&q1).await;
                    let mut result = Result(&q1);
                    result.add_result(&q1.measure_z().await).await;
                    message.append_body(&result).await;
                    send(&message).await;
                    self.parent_ruleset
                        .borrow_mut()
                        .__register_return_val(&self.name, q0.await);
                })()
                .await;
                return true;
            } else {
                return false;
            };
        }
        fn post_process(&self) {}
        async fn execute(&self) {
            loop {
                let __done = self.condition().await;
                if __done {
                    break;
                }
                sleep(Duration::from_micros(100));
            }
        }
    }
    pub struct parity_check {
        name: String,
        interface_names: Vec<String>,
        arguments: HashMap<String, Argument>,
        parent_ruleset: Rc<RefCell<RuleSetExec>>,
    }
    pub struct unready_parity_check {
        name: String,
        interface_names: Vec<String>,
        static_interfaces: __StaticInterface,
        arguments: HashMap<String, Argument>,
        parent_ruleset: Rc<RefCell<RuleSetExec>>,
    }
    impl unready_parity_check {
        pub fn new(
            __static_interface: __StaticInterface,
            parent_ruleset: Rc<RefCell<RuleSetExec>>,
        ) -> unready_parity_check {
            let mut empty_argument = HashMap::new();
            let arg = Argument::init();
            empty_argument.insert("self_result".to_string(), arg);
            let arg = Argument::init();
            empty_argument.insert("distance".to_string(), arg);
            unready_parity_check {
                name: String::from("parity_check"),
                interface_names: vec!["qn1".to_string(), "qn0".to_string()],
                static_interfaces: __static_interface,
                arguments: empty_argument,
                parent_ruleset: parent_ruleset,
            }
        }
        pub fn argument_resolved(&self) -> Option<ReadyRules> {
            for (_, arg) in &self.arguments {
                if !arg.resolved() {
                    return None;
                }
            }
            Some(ReadyRules::parity_check(parity_check {
                name: self.name.clone(),
                interface_names: self.interface_names.clone(),
                arguments: self.arguments.clone(),
                parent_ruleset: self.parent_ruleset.clone(),
            }))
        }
        pub fn arg_exist(&self, arg_name: &str) -> bool {
            self.arguments.contains_key(arg_name)
        }
        pub fn resolve_argument(&mut self, arg_name: &str, new_arg: Argument) {
            let mut arg = self
                .arguments
                .get_mut(arg_name)
                .expect("Unable to find argument");
            *arg = new_arg
        }
        pub fn arg_list(&self) -> Vec<String> {
            let mut arg_vec = vec![];
            for (arg, _) in &self.arguments {
                arg_vec.push(arg.clone());
            }
            arg_vec
        }
        pub fn register_return_val(&mut self, rule_name: &str, argument: Argument) {
            self.parent_ruleset
                .borrow_mut()
                .__register_return_val(rule_name, argument);
        }
        #[doc = "No execution, but gen ruleset"]
        fn static_ruleset_gen(&mut self) -> Stage<ActionClausesV2> {
            let mut stage = Stage::<ActionClausesV2>::new();
            #[doc = "Initialy, this starts just a single rule, but if there is match or if expression, this should be expanded."]
            let rules = Rc::new(RefCell::new(vec![RefCell::new(
                Rule::<ActionClausesV2>::new("parity_check"),
            )]));
            let mut message = self
                .static_interfaces
                .__get_interface("qn0")
                .__static__get_message(
                    Rc::clone(&rules),
                    self.static_interfaces
                        .__get_interface("qn0")
                        .__static__get_partner_by_hop(
                            Rc::clone(&rules),
                            self.arguments
                                .get("distance")
                                .unwrap()
                                .eval_unsigned_int64()
                                .clone(),
                        )
                        .clone(),
                );
            let _ = __static__comp(
                message.kind,
                __CmpOp::Eq,
                "purification".to_string(),
                false,
                Rc::clone(&rules),
            );
            let mut target_qubit = self
                .static_interfaces
                .__get_interface("qn0")
                .__static__get_qubit_by_partner(
                    Rc::clone(&rules),
                    message.src.clone(),
                    message.body.result.qubit_address.clone(),
                );
            let __rules = rules.clone();
            let mut __temp_rule_store = vec![];
            let final_num_rule = rules.borrow().len() * 2;
            let rules = __rules.clone();
            __static__comp(
                message.body.result.__static__get_output(Rc::clone(&rules)),
                __CmpOp::Eq,
                self.arguments.get("self_result").unwrap().eval_str(),
                false,
                Rc::clone(&rules),
            );
            __static__promote(Rc::clone(&rules), target_qubit.clone());
            for __gen_rule in &*rules.borrow() {
                __temp_rule_store.push(__gen_rule.clone());
            }
            let rules = __rules.clone();
            __static__comp(
                message.body.result.__static__get_output(Rc::clone(&rules)),
                __CmpOp::Eq,
                self.arguments.get("self_result").unwrap().eval_str(),
                true,
                Rc::clone(&rules),
            );
            __static__free(Rc::clone(&rules), target_qubit.clone());
            for __gen_rule in &*rules.borrow() {
                __temp_rule_store.push(__gen_rule.clone());
            }
            let rules = Rc::new(RefCell::new(vec![]));
            for __rule in __temp_rule_store {
                rules.borrow_mut().push(__rule.clone());
            }
            if rules.borrow().len() != final_num_rule {
                panic!("Errors on the number of rules")
            };
            for rule in &*rules.borrow() {
                stage.add_rule(rule.borrow().clone());
            }
            stage
        }
        fn gen_ruleset(&mut self, ruleset: &mut RuleSet<ActionClausesV2>) {
            let stage = self.static_ruleset_gen();
            ruleset.add_stage(stage);
        }
    }
    impl parity_check {
        async fn condition(&self) -> bool {
            let interface = INTERFACES
                .get()
                .expect("Unable to get interface table")
                .lock()
                .await;
            let mut message = interface
                .get("qn0")
                .expect("unable to get interface")
                .get_message(
                    &interface
                        .get("qn0")
                        .expect("unable to get interface")
                        .get_partner_by_hop(
                            &self
                                .arguments
                                .get("distance")
                                .unwrap()
                                .eval_unsigned_int64(),
                        )
                        .await,
                )
                .await;
            if __comp(message.kind, __CmpOp::Eq, "purification".to_string()) {
                (|| async {
                    let mut target_qubit = interface
                        .get("qn0")
                        .expect("unable to get interface")
                        .get_qubit_by_partner(&message.src, &message.body.result.qubit_address)
                        .await;
                    if __comp(
                        message.body.result.get_output().await,
                        __CmpOp::Eq,
                        self.arguments.get("self_result").unwrap().eval_str(),
                    ) {
                        promote(&target_qubit).await
                    } else {
                        free(&target_qubit).await
                    };
                })()
                .await;
                return true;
            } else {
                return false;
            };
        }
        fn post_process(&self) {}
        async fn execute(&self) {
            loop {
                let __done = self.condition().await;
                if __done {
                    break;
                }
                sleep(Duration::from_micros(100));
            }
        }
    }
    pub struct RuleSetExec {
        name: String,
        unready_rules: HashMap<String, UnreadyRules>,
        rules: HashMap<String, ReadyRules>,
        returned_values: HashMap<String, Argument>,
    }
    impl RuleSetExec {
        pub fn init() -> Self {
            RuleSetExec {
                name: "purification".to_string(),
                unready_rules: HashMap::new(),
                rules: HashMap::new(),
                returned_values: HashMap::new(),
            }
        }
        pub fn __register_return_val(&mut self, arg_name: &str, value: Argument) {
            self.returned_values.insert(arg_name.to_string(), value);
        }
        pub fn add_unready_rule(&mut self, name: String, rule: UnreadyRules) {
            self.unready_rules.insert(name, rule);
        }
        pub fn check_arg_resolved(&mut self) {
            for (rname, u_rule) in &self.unready_rules {
                match u_rule.check_arg_resolved() {
                    Some(resolved_rule) => {
                        self.rules.insert(rname.to_string(), resolved_rule);
                    }
                    None => {}
                }
            }
        }
        pub fn resolve_config(&mut self, config: Box<&CONFIG>, index: Option<usize>) {
            for (_, rule) in &mut self.unready_rules {
                for arg in &mut rule.arg_list() {
                    match config.__get_as_arg(arg, index) {
                        Some(argument) => rule.resolve_argument(arg, argument),
                        None => {
                            rule.resolve_argument(arg, Argument::init());
                        }
                    }
                }
            }
        }
        pub fn gen_ruleset(&mut self, ruleset: &mut RuleSet<ActionClausesV2>, owner: u32) {
            ruleset.update_name(&self.name);
            ruleset.update_owner_addr(Some(AddressKind::IntegerKind(owner)));
            for rname in vec!["local_operation", "parity_check"] {
                let mut unready_rule = self
                    .unready_rules
                    .get_mut(rname)
                    .expect("Unable to find the rules");
                for (ret_arg_name, arg) in self.returned_values.iter() {
                    if unready_rule.arg_list().contains(&ret_arg_name) {
                        unready_rule.resolve_argument(&ret_arg_name, arg.clone());
                    }
                }
                self.unready_rules
                    .get_mut(rname)
                    .expect("unable to find rule")
                    .gen_ruleset(ruleset);
            }
        }
        pub async fn execute(&self) {}
    }
}
#[allow(unused_mut)]
pub fn __gen_static_rulesets(rulesets: &mut Vec<RuleSet<ActionClauses>>, config: rula::CONFIG) {
    let __static_interface_list = rula::initialize_static_interface(100);
    for i in 0..100 {
        let mut ruleset = Rc::new(RefCell::new(rula::RuleSetExec::init()));
        ruleset.borrow_mut().add_unready_rule(
            String::from("local_operation"),
            rula::UnreadyRules::unready_local_operation(rula::unready_local_operation::new(
                __static_interface_list.__get_interface(i),
                Rc::clone(&ruleset),
            )),
        );
        ruleset.borrow_mut().add_unready_rule(
            String::from("parity_check"),
            rula::UnreadyRules::unready_parity_check(rula::unready_parity_check::new(
                __static_interface_list.__get_interface(i),
                Rc::clone(&ruleset),
            )),
        );
        ruleset
            .borrow_mut()
            .resolve_config(Box::new(&config), Some(i as usize));
        let mut static_ruleset = RuleSet::<ActionClauses>::new("");
        ruleset
            .borrow_mut()
            .gen_ruleset(&mut static_ruleset, i as u32);
        let output_file_path = format!("tests/generated/test_{}.json", i);
        let mut file = File::create(output_file_path).expect("Failed to create a new file");
        let json_ruleset = serde_json::to_string(&static_ruleset).unwrap();
        write!(&file, "{}", json_ruleset).unwrap();
        file.flush().expect("Failed to write");
        rulesets.push(static_ruleset);
    }
}
pub async fn __execute_ruleset() {
    rula::initialize_interface().await;
}
pub async fn main() {
    let mut rulesets = vec![];
    let content = fs::read_to_string("../examples/single_purification.toml").unwrap();
    let mut config: rula::CONFIG = toml::from_str(&content).unwrap();
    config.__finalize();
    __gen_static_rulesets(&mut rulesets, config);
}
#[cfg(test)]
mod tests {
    use super::rula::*;
    use super::*;
    #[doc = "This is generated for entanglement_swapping.rula"]
    #[tokio::test]
    async fn test_interface() {
        assert!(INTERFACES.get().is_none());
        rula::initialize_interface().await;
        let interface = INTERFACES.get().expect("Failed to get interface table");
        assert!(interface.lock().await.contains_key("qn0"));
        assert!(interface.lock().await.contains_key("qn1"));
    }
    #[tokio::test]
    async fn run_main() {
        main().await;
        assert_eq!(1, 1);
    }
}
