// This is autogenerated Rust program
use crate::rula_std::ruleset::ruleset::*;
use rula_lib as rula_std;
use rula_std::ruleset::action::v2::ActionClauses;
use std::cell::RefCell;
use std::fs;
use std::fs::File;
use std::io::Write;
use std::rc::Rc;
#[allow(non_snake_case)]
#[allow(non_camel_case_types)]
#[allow(unused_doc_comments)]
#[allow(dead_code)]
#[allow(warnings, unused)]
mod rula {
    use super::*;
    use once_cell::sync::OnceCell;
    use rula_std::message::*;
    use rula_std::operation::*;
    use rula_std::prelude::*;
    use rula_std::qnic::*;
    use rula_std::qubit::*;
    use rula_std::result::*;
    use rula_std::ruleset::action::v2::ActionClauses as ActionClausesV2;
    use rula_std::ruleset::condition::v1::ConditionClauses;
    use rula_std::ruleset::condition::v1::*;
    use rula_std::ruleset::ruleset::*;
    use rula_std::RuleVec;
    use serde::{Deserialize, Serialize};
    use std::cell::RefCell;
    use std::collections::{HashMap, HashSet};
    use std::iter::FromIterator;
    use std::rc::Rc;
    use tokio::sync::Mutex as TokioMutex;
    use tokio::time::{sleep, Duration};
    pub static INTERFACES: OnceCell<TokioMutex<HashMap<String, QnicInterface>>> = OnceCell::new();
    pub enum UnreadyRules {
        unready_swapping(unready_swapping),
        unready_pauli_correction(unready_pauli_correction),
    }
    impl UnreadyRules {
        pub fn check_arg_resolved(&self) -> Option<ReadyRules> {
            match &self {
                UnreadyRules::unready_swapping(unready_swapping) => {
                    unready_swapping.argument_resolved()
                }
                UnreadyRules::unready_pauli_correction(unready_pauli_correction) => {
                    unready_pauli_correction.argument_resolved()
                }
                _ => {
                    panic!("No rule name found");
                }
            }
        }
        pub fn arg_list(&self) -> Vec<String> {
            match &self {
                UnreadyRules::unready_swapping(unready_swapping) => unready_swapping.arg_list(),
                UnreadyRules::unready_pauli_correction(unready_pauli_correction) => {
                    unready_pauli_correction.arg_list()
                }
                _ => {
                    panic!("No rule name found");
                }
            }
        }
        pub fn resolve_argument(&mut self, arg_name: &str, argument: Argument) {
            match self {
                UnreadyRules::unready_swapping(unready_swapping) => {
                    unready_swapping.resolve_argument(arg_name, argument);
                }
                UnreadyRules::unready_pauli_correction(unready_pauli_correction) => {
                    unready_pauli_correction.resolve_argument(arg_name, argument);
                }
                _ => {
                    panic!("No rule name found");
                }
            }
        }
        pub fn gen_ruleset(&mut self, ruleset: &mut RuleSet<ActionClausesV2>) {
            match self {
                UnreadyRules::unready_swapping(unready_swapping) => {
                    unready_swapping.gen_ruleset(ruleset);
                }
                UnreadyRules::unready_pauli_correction(unready_pauli_correction) => {
                    unready_pauli_correction.gen_ruleset(ruleset);
                }
                _ => {
                    panic!("No rule name found")
                }
            }
        }
    }
    pub enum ReadyRules {
        swapping(swapping),
        pauli_correction(pauli_correction),
    }
    use rula_std::message::Message;
    use rula_std::operation::bsm;
    use rula_std::result::Result;
    use rula_std::time::time;
    pub async fn initialize_interface() {
        assert!(INTERFACES.get().is_none());
        let initialize_interface = || TokioMutex::new(HashMap::new());
        INTERFACES.get_or_init(initialize_interface);
        let interface_list = INTERFACES.get().expect("Failed to get interface");
        for (index, interface_name) in vec!["qn0", "qn1", "qnall"].iter().enumerate() {
            let mock_qnic =
                QnicInterface::generate_mock_interface(index as u32, interface_name, 10);
            interface_list
                .lock()
                .await
                .insert(interface_name.to_string(), mock_qnic);
        }
    }
    pub fn initialize_static_interface(__num_nodes: u64) -> __StaticInterfaceList {
        let mut __static_interface_list = __StaticInterfaceList::new();
        __static_interface_list.__update_num_node(__num_nodes);
        for _ in 0..__num_nodes {
            let mut __static_interface = __StaticInterface::new();
            for (index, i_name) in vec!["qn0", "qn1", "qnall"].iter().enumerate() {
                __static_interface.__add_interface_name(i_name);
                let qnic_interface =
                    QnicInterface::generate_mock_interface(index as u32, i_name, 10);
                __static_interface.__add_interface(i_name, qnic_interface);
            }
            __static_interface_list.__add_static_interface(__static_interface);
        }
        __static_interface_list.__check();
        __static_interface_list
    }
    type NodeNumber = u64;
    #[derive(Debug, Serialize, Deserialize)]
    pub struct __StaticInterfaceList {
        pub num_nodes: u64,
        pub __static_interfaces: HashMap<NodeNumber, __StaticInterface>,
        index: u64,
    }
    impl __StaticInterfaceList {
        pub fn new() -> Self {
            __StaticInterfaceList {
                num_nodes: 0,
                __static_interfaces: HashMap::new(),
                index: 0,
            }
        }
        pub fn __add_static_interface(&mut self, __static_interface: __StaticInterface) {
            self.__static_interfaces
                .insert(self.index, __static_interface);
            self.index += 1;
        }
        pub fn __get_interface(&self, index: NodeNumber) -> __StaticInterface {
            self.__static_interfaces
                .get(&index)
                .expect("No interface found")
                .clone()
        }
        pub fn __update_num_node(&mut self, num_nodes: u64) {
            self.num_nodes = num_nodes;
        }
        pub fn __check(&self) {
            if self.__static_interfaces.len() != self.num_nodes as usize {
                panic!("The qnics are not properly registered")
            }
        }
    }
    #[derive(Debug, Serialize, Deserialize, Clone)]
    pub struct __StaticInterface {
        pub interface_names: HashSet<String>,
        pub interfaces: HashMap<String, QnicInterface>,
    }
    impl __StaticInterface {
        pub fn new() -> Self {
            __StaticInterface {
                interface_names: HashSet::new(),
                interfaces: HashMap::new(),
            }
        }
        pub fn __add_interface_name(&mut self, value: &str) {
            if !self.interface_names.contains(value) {
                self.interface_names.insert(value.to_string());
            } else {
                panic!("Interface name duplication {}", value);
            }
        }
        pub fn __add_interface(&mut self, name: &str, qnic: QnicInterface) {
            if self.interface_names.contains(name) {
                self.interfaces.insert(name.to_string(), qnic);
            } else {
                panic!("No interface found {}", name);
            }
        }
        pub fn __get_interface(&self, interface_name: &str) -> QnicInterface {
            self.interfaces
                .get(interface_name)
                .expect("Failed to get interface")
                .clone()
        }
    }
    #[derive(Debug, Serialize, Deserialize)]
    pub struct CONFIG {
        pub distance: Vec<u64>,
        __names: Option<HashSet<String>>,
        __num_nodes: Option<u64>,
    }
    impl CONFIG {
        pub fn __finalize(&mut self) {
            let keys = vec!["distance".to_string()];
            self.__names = Some(HashSet::from_iter(keys.iter().cloned()));
            self.__num_nodes = Some(512)
        }
        fn __key_exist(&self, value: &str) -> bool {
            self.__names
                .as_ref()
                .expect("Unable to find config item names")
                .contains(value)
        }
        pub fn __get_as_arg(&self, config_val: &str, index: Option<usize>) -> Option<Argument> {
            if self.__key_exist(config_val) {
                match config_val {
                    "distance" => {
                        let mut arg = Argument::init();
                        match index {
                            Some(ind) => {
                                arg.add_argument(
                                    ArgVal::UnsignedInteger64(self.distance[ind].clone()),
                                    LibTypeHint::UnsignedInteger64,
                                );
                                Some(arg)
                            }
                            None => {
                                arg.add_argument(
                                    ArgVal::U64Vector(self.distance.clone()),
                                    LibTypeHint::Vector(Box::new(LibTypeHint::UnsignedInteger64)),
                                );
                                Some(arg)
                            }
                        }
                    }
                    _ => {
                        panic!("This should not happen")
                    }
                }
            } else {
                None
            }
        }
    }
    pub struct swapping {
        name: String,
        interface_names: Vec<String>,
        arguments: HashMap<String, Argument>,
        parent_ruleset: Rc<RefCell<RuleSetExec>>,
    }
    pub struct unready_swapping {
        name: String,
        interface_names: Vec<String>,
        static_interfaces: __StaticInterface,
        arguments: HashMap<String, Argument>,
        parent_ruleset: Rc<RefCell<RuleSetExec>>,
    }
    impl unready_swapping {
        pub fn new(
            __static_interface: __StaticInterface,
            parent_ruleset: Rc<RefCell<RuleSetExec>>,
        ) -> unready_swapping {
            let mut empty_argument = HashMap::new();
            let arg = Argument::init();
            empty_argument.insert("distance".to_string(), arg);
            unready_swapping {
                name: String::from("swapping"),
                interface_names: vec!["qn0".to_string(), "qn1".to_string()],
                static_interfaces: __static_interface,
                arguments: empty_argument,
                parent_ruleset: parent_ruleset,
            }
        }
        pub fn argument_resolved(&self) -> Option<ReadyRules> {
            for (_, arg) in &self.arguments {
                if !arg.resolved() {
                    return None;
                }
            }
            Some(ReadyRules::swapping(swapping {
                name: self.name.clone(),
                interface_names: self.interface_names.clone(),
                arguments: self.arguments.clone(),
                parent_ruleset: self.parent_ruleset.clone(),
            }))
        }
        pub fn arg_exist(&self, arg_name: &str) -> bool {
            self.arguments.contains_key(arg_name)
        }
        pub fn resolve_argument(&mut self, arg_name: &str, new_arg: Argument) {
            let mut arg = self
                .arguments
                .get_mut(arg_name)
                .expect("Unable to find argument");
            *arg = new_arg
        }
        pub fn arg_list(&self) -> Vec<String> {
            let mut arg_vec = vec![];
            for (arg, _) in &self.arguments {
                arg_vec.push(arg.clone());
            }
            arg_vec
        }
        pub fn register_return_val(&mut self, rule_name: &str, argument: Argument) {
            self.parent_ruleset
                .borrow_mut()
                .__register_return_val(rule_name, argument);
        }
        #[doc = "No execution, but gen ruleset"]
        fn static_ruleset_gen(&mut self) -> Stage<ActionClausesV2> {
            let mut stage = Stage::<ActionClausesV2>::new();
            #[doc = "Initialy, this starts just a single rule, but if there is match or if expression, this should be expanded."]
            let rules = Rc::new(RefCell::new(vec![RefCell::new(
                Rule::<ActionClausesV2>::new("swapping"),
            )]));
            let mut q1: QubitInterface = self
                .static_interfaces
                .__get_interface("qn0")
                .__static__request_resource(
                    Rc::clone(&rules),
                    1.clone(),
                    self.static_interfaces
                        .__get_interface("qn0")
                        .__static__get_partner_by_hop(
                            Rc::clone(&rules),
                            self.arguments
                                .get("distance")
                                .unwrap()
                                .eval_unsigned_int64()
                                .clone(),
                        )
                        .clone(),
                );
            let mut q2: QubitInterface = self
                .static_interfaces
                .__get_interface("qn1")
                .__static__request_resource(
                    Rc::clone(&rules),
                    1.clone(),
                    self.static_interfaces
                        .__get_interface("qn1")
                        .__static__get_partner_by_hop(
                            Rc::clone(&rules),
                            self.arguments
                                .get("distance")
                                .unwrap()
                                .eval_unsigned_int64()
                                .clone(),
                        )
                        .clone(),
                );
            let _ = __static__comp(
                self.arguments
                    .get("distance")
                    .unwrap()
                    .eval_unsigned_int64(),
                __CmpOp::Gt,
                0,
                false,
                Rc::clone(&rules),
            );
            let _ = q1.__static__ready(Rc::clone(&rules));
            let _ = q2.__static__ready(Rc::clone(&rules));
            let mut message = __static__Message(
                Rc::clone(&rules),
                "swapping".to_string().clone(),
                self.static_interfaces
                    .__get_interface("qn0")
                    .address
                    .clone(),
                self.static_interfaces
                    .__get_interface("qn0")
                    .__static__get_partner_by_hop(
                        Rc::clone(&rules),
                        self.arguments
                            .get("distance")
                            .unwrap()
                            .eval_unsigned_int64()
                            .clone(),
                    )
                    .clone(),
            );
            let mut result = __static__Result(Rc::clone(&rules), q1.clone());
            result
                .__static__add_tag(Rc::clone(&rules), "meas_result".to_string().clone())
                .__static__add_result(
                    Rc::clone(&rules),
                    __static__bsm(Rc::clone(&rules), q1.clone(), q2.clone()).clone(),
                );
            message.__static__append_body(Rc::clone(&rules), result.clone());
            __static__send(Rc::clone(&rules), message.clone());
            for rule in &*rules.borrow() {
                stage.add_rule(rule.borrow().clone());
            }
            stage
        }
        fn gen_ruleset(&mut self, ruleset: &mut RuleSet<ActionClausesV2>) {
            let stage = self.static_ruleset_gen();
            ruleset.add_stage(stage);
        }
    }
    impl swapping {
        async fn condition(&self) -> bool {
            let interface = INTERFACES
                .get()
                .expect("Unable to get interface table")
                .lock()
                .await;
            let mut q1: QubitInterface = interface
                .get("qn0")
                .expect("unable to get interface")
                .request_resource(
                    &1,
                    &interface
                        .get("qn0")
                        .expect("unable to get interface")
                        .get_partner_by_hop(
                            &self
                                .arguments
                                .get("distance")
                                .unwrap()
                                .eval_unsigned_int64(),
                        )
                        .await,
                )
                .await;
            let mut q2: QubitInterface = interface
                .get("qn1")
                .expect("unable to get interface")
                .request_resource(
                    &1,
                    &interface
                        .get("qn1")
                        .expect("unable to get interface")
                        .get_partner_by_hop(
                            &self
                                .arguments
                                .get("distance")
                                .unwrap()
                                .eval_unsigned_int64(),
                        )
                        .await,
                )
                .await;
            if __comp(
                self.arguments
                    .get("distance")
                    .unwrap()
                    .eval_unsigned_int64(),
                __CmpOp::Gt,
                0,
            ) && q1.ready().await
                && q2.ready().await
            {
                (|| async {
                    let mut message = Message(
                        &"swapping".to_string(),
                        &interface
                            .get("qn0")
                            .expect("unable to get interface")
                            .address,
                        &interface
                            .get("qn0")
                            .expect("unable to get interface")
                            .get_partner_by_hop(
                                &self
                                    .arguments
                                    .get("distance")
                                    .unwrap()
                                    .eval_unsigned_int64(),
                            )
                            .await,
                    );
                    let mut result = Result(&q1);
                    result
                        .add_tag(&"meas_result".to_string())
                        .await
                        .add_result(&bsm(&q1, &q2).await)
                        .await;
                    message.append_body(&result).await;
                    send(&message).await;
                })()
                .await;
                return true;
            } else {
                return false;
            };
        }
        fn post_process(&self) {}
        async fn execute(&self) {
            loop {
                let __done = self.condition().await;
                if __done {
                    break;
                }
                sleep(Duration::from_micros(100));
            }
        }
    }
    pub struct pauli_correction {
        name: String,
        interface_names: Vec<String>,
        arguments: HashMap<String, Argument>,
        parent_ruleset: Rc<RefCell<RuleSetExec>>,
    }
    pub struct unready_pauli_correction {
        name: String,
        interface_names: Vec<String>,
        static_interfaces: __StaticInterface,
        arguments: HashMap<String, Argument>,
        parent_ruleset: Rc<RefCell<RuleSetExec>>,
    }
    impl unready_pauli_correction {
        pub fn new(
            __static_interface: __StaticInterface,
            parent_ruleset: Rc<RefCell<RuleSetExec>>,
        ) -> unready_pauli_correction {
            let mut empty_argument = HashMap::new();
            let arg = Argument::init();
            empty_argument.insert("distance".to_string(), arg);
            unready_pauli_correction {
                name: String::from("pauli_correction"),
                interface_names: vec!["qn0".to_string()],
                static_interfaces: __static_interface,
                arguments: empty_argument,
                parent_ruleset: parent_ruleset,
            }
        }
        pub fn argument_resolved(&self) -> Option<ReadyRules> {
            for (_, arg) in &self.arguments {
                if !arg.resolved() {
                    return None;
                }
            }
            Some(ReadyRules::pauli_correction(pauli_correction {
                name: self.name.clone(),
                interface_names: self.interface_names.clone(),
                arguments: self.arguments.clone(),
                parent_ruleset: self.parent_ruleset.clone(),
            }))
        }
        pub fn arg_exist(&self, arg_name: &str) -> bool {
            self.arguments.contains_key(arg_name)
        }
        pub fn resolve_argument(&mut self, arg_name: &str, new_arg: Argument) {
            let mut arg = self
                .arguments
                .get_mut(arg_name)
                .expect("Unable to find argument");
            *arg = new_arg
        }
        pub fn arg_list(&self) -> Vec<String> {
            let mut arg_vec = vec![];
            for (arg, _) in &self.arguments {
                arg_vec.push(arg.clone());
            }
            arg_vec
        }
        pub fn register_return_val(&mut self, rule_name: &str, argument: Argument) {
            self.parent_ruleset
                .borrow_mut()
                .__register_return_val(rule_name, argument);
        }
        #[doc = "No execution, but gen ruleset"]
        fn static_ruleset_gen(&mut self) -> Stage<ActionClausesV2> {
            let mut stage = Stage::<ActionClausesV2>::new();
            #[doc = "Initialy, this starts just a single rule, but if there is match or if expression, this should be expanded."]
            let rules = Rc::new(RefCell::new(vec![RefCell::new(
                Rule::<ActionClausesV2>::new("pauli_correction"),
            )]));
            let mut message = self
                .static_interfaces
                .__get_interface("qn0")
                .__static__get_message(
                    Rc::clone(&rules),
                    self.static_interfaces
                        .__get_interface("qn0")
                        .__static__get_partner_by_hop(
                            Rc::clone(&rules),
                            self.arguments
                                .get("distance")
                                .unwrap()
                                .eval_unsigned_int64()
                                .clone(),
                        )
                        .clone(),
                );
            let _ = __static__comp(
                message.kind,
                __CmpOp::Eq,
                "swapping".to_string(),
                false,
                Rc::clone(&rules),
            );
            let mut target_qubit: QubitInterface = self
                .static_interfaces
                .__get_interface("qn0")
                .__static__get_qubit_by_partner(
                    Rc::clone(&rules),
                    message.src.clone(),
                    message.body.result.qubit_address.clone(),
                );
            let (__temp_val, __cmp_kind, __cmp_target) =
                message.body.result.__static__get_result(Rc::clone(&rules));
            let __cmp_conditions = vec![
                (__cmp_kind.clone(), CmpOp::Eq, __cmp_target("00")),
                (__cmp_kind.clone(), CmpOp::Eq, __cmp_target("01")),
                (__cmp_kind.clone(), CmpOp::Eq, __cmp_target("10")),
                (__cmp_kind.clone(), CmpOp::Eq, __cmp_target("11")),
            ];
            let __cmp_actions: Vec<Box<dyn Fn(Rule<ActionClausesV2>) -> (RuleVec)>> = vec![
                Box::new(|__new_rule| {
                    let __temp_rules = Rc::new(RefCell::new(vec![RefCell::new(__new_rule)]));
                    __temp_rules
                }),
                Box::new(|__new_rule| {
                    let __temp_rules = Rc::new(RefCell::new(vec![RefCell::new(__new_rule)]));
                    target_qubit.__static__z(Rc::clone(&__temp_rules));
                    __temp_rules
                }),
                Box::new(|__new_rule| {
                    let __temp_rules = Rc::new(RefCell::new(vec![RefCell::new(__new_rule)]));
                    target_qubit.__static__x(Rc::clone(&__temp_rules));
                    __temp_rules
                }),
                Box::new(|__new_rule| {
                    let __temp_rules = Rc::new(RefCell::new(vec![RefCell::new(__new_rule)]));
                    target_qubit.__static__z(Rc::clone(&__temp_rules));
                    target_qubit.__static__x(Rc::clone(&__temp_rules));
                    __temp_rules
                }),
            ];
            let updated_num_rules = rules.borrow().len() * __cmp_actions.len();
            let finally_rules = &*rules.clone();
            let mut new_rule_vec = vec![];
            for rule in &*rules.borrow_mut() {
                for ((__cmp_val, __cmp_op, __val), __action_func) in
                    &mut __cmp_conditions.iter().zip(&__cmp_actions)
                {
                    let mut cloned_rule = rule.borrow().clone();
                    cloned_rule.add_condition_clause(ConditionClauses::Cmp(Cmp::new(
                        __cmp_val.clone(),
                        __cmp_op.clone(),
                        __val.clone(),
                    )));
                    let generated_rules = __action_func(cloned_rule);
                    for gen_rule in &*generated_rules.borrow() {
                        new_rule_vec.push(gen_rule.clone());
                    }
                }
            }
            let mut rules = Rc::new(RefCell::new(vec![]));
            for new_rule in new_rule_vec {
                rules.borrow_mut().push(new_rule);
            }
            let num_rules = rules.borrow().len();
            if num_rules != updated_num_rules {
                panic!(
                    "The final rule size is wrong Suppose: {} != Actual{}",
                    updated_num_rules, num_rules
                );
            }
            let mut fin_rule_stack = vec![];
            for fin_rule in &*finally_rules.borrow_mut() {
                let generated_vec = (|__new_rule| {
                    let __temp_rules = Rc::new(RefCell::new(vec![RefCell::new(__new_rule)]));
                    __static__free(Rc::clone(&__temp_rules), target_qubit.clone());
                    __temp_rules
                })(fin_rule.borrow().clone());
                for gen_rule in &*generated_vec.borrow() {
                    fin_rule_stack.push(gen_rule.clone());
                }
            }
            for finally_rule in &fin_rule_stack {
                rules.borrow_mut().push(finally_rule.clone());
            }
            for rule in &*rules.borrow() {
                stage.add_rule(rule.borrow().clone());
            }
            stage
        }
        fn gen_ruleset(&mut self, ruleset: &mut RuleSet<ActionClausesV2>) {
            let stage = self.static_ruleset_gen();
            ruleset.add_stage(stage);
        }
    }
    impl pauli_correction {
        async fn condition(&self) -> bool {
            let interface = INTERFACES
                .get()
                .expect("Unable to get interface table")
                .lock()
                .await;
            let mut message = interface
                .get("qn0")
                .expect("unable to get interface")
                .get_message(
                    &interface
                        .get("qn0")
                        .expect("unable to get interface")
                        .get_partner_by_hop(
                            &self
                                .arguments
                                .get("distance")
                                .unwrap()
                                .eval_unsigned_int64(),
                        )
                        .await,
                )
                .await;
            if __comp(message.kind, __CmpOp::Eq, "swapping".to_string()) {
                (|| async {
                    let mut target_qubit: QubitInterface = interface
                        .get("qn0")
                        .expect("unable to get interface")
                        .get_qubit_by_partner(&message.src, &message.body.result.qubit_address)
                        .await;
                    let result = message.body.result.get_result();
                    match result {
                        "00" => {}
                        "01" => target_qubit.z().await,
                        "10" => target_qubit.x().await,
                        "11" => {
                            target_qubit.z().await;
                            target_qubit.x().await
                        }
                        _ => free(&target_qubit).await,
                    };
                })()
                .await;
                return true;
            } else {
                return false;
            };
        }
        fn post_process(&self) {}
        async fn execute(&self) {
            loop {
                let __done = self.condition().await;
                if __done {
                    break;
                }
                sleep(Duration::from_micros(100));
            }
        }
    }
    pub struct RuleSetExec {
        name: String,
        unready_rules: HashMap<String, UnreadyRules>,
        rules: HashMap<String, ReadyRules>,
        returned_values: HashMap<String, Argument>,
    }
    impl RuleSetExec {
        pub fn init() -> Self {
            RuleSetExec {
                name: "entanglement_swapping".to_string(),
                unready_rules: HashMap::new(),
                rules: HashMap::new(),
                returned_values: HashMap::new(),
            }
        }
        pub fn __register_return_val(&mut self, arg_name: &str, value: Argument) {
            self.returned_values.insert(arg_name.to_string(), value);
        }
        pub fn add_unready_rule(&mut self, name: String, rule: UnreadyRules) {
            self.unready_rules.insert(name, rule);
        }
        pub fn check_arg_resolved(&mut self) {
            for (rname, u_rule) in &self.unready_rules {
                match u_rule.check_arg_resolved() {
                    Some(resolved_rule) => {
                        self.rules.insert(rname.to_string(), resolved_rule);
                    }
                    None => {}
                }
            }
        }
        pub fn resolve_config(&mut self, config: Box<&CONFIG>, index: Option<usize>) {
            for (_, rule) in &mut self.unready_rules {
                for arg in &mut rule.arg_list() {
                    match config.__get_as_arg(arg, index) {
                        Some(argument) => rule.resolve_argument(arg, argument),
                        None => {
                            rule.resolve_argument(arg, Argument::init());
                        }
                    }
                }
            }
        }
        pub fn gen_ruleset(&mut self, ruleset: &mut RuleSet<ActionClausesV2>, owner: u32) {
            ruleset.update_name(&self.name);
            ruleset.update_owner_addr(Some(AddressKind::IntegerKind(owner)));
            for rname in vec!["swapping", "pauli_correction"] {
                let mut unready_rule = self
                    .unready_rules
                    .get_mut(rname)
                    .expect("Unable to find the rules");
                for (ret_arg_name, arg) in self.returned_values.iter() {
                    if unready_rule.arg_list().contains(&ret_arg_name) {
                        unready_rule.resolve_argument(&ret_arg_name, arg.clone());
                    }
                }
                self.unready_rules
                    .get_mut(rname)
                    .expect("unable to find rule")
                    .gen_ruleset(ruleset);
            }
        }
        pub async fn execute(&self) {}
    }
}
#[allow(unused_mut)]
pub fn __gen_static_rulesets(rulesets: &mut Vec<RuleSet<ActionClauses>>, config: rula::CONFIG) {
    let __static_interface_list = rula::initialize_static_interface(512);
    for i in 0..512 {
        let mut ruleset = Rc::new(RefCell::new(rula::RuleSetExec::init()));
        ruleset.borrow_mut().add_unready_rule(
            String::from("swapping"),
            rula::UnreadyRules::unready_swapping(rula::unready_swapping::new(
                __static_interface_list.__get_interface(i),
                Rc::clone(&ruleset),
            )),
        );
        ruleset.borrow_mut().add_unready_rule(
            String::from("pauli_correction"),
            rula::UnreadyRules::unready_pauli_correction(rula::unready_pauli_correction::new(
                __static_interface_list.__get_interface(i),
                Rc::clone(&ruleset),
            )),
        );
        ruleset
            .borrow_mut()
            .resolve_config(Box::new(&config), Some(i as usize));
        let mut static_ruleset = RuleSet::<ActionClauses>::new("");
        ruleset
            .borrow_mut()
            .gen_ruleset(&mut static_ruleset, i as u32);
        let output_file_path = format!("tests/generated/test_{}.json", i);
        let mut file = File::create(output_file_path).expect("Failed to create a new file");
        let json_ruleset = serde_json::to_string(&static_ruleset).unwrap();
        write!(&file, "{}", json_ruleset).unwrap();
        file.flush().expect("Failed to write");
        rulesets.push(static_ruleset);
    }
}
pub async fn __execute_ruleset() {
    rula::initialize_interface().await;
}
pub async fn main() {
    let mut rulesets = vec![];
    let content = fs::read_to_string("../examples/entanglement_swapping.toml").unwrap();
    let mut config: rula::CONFIG = toml::from_str(&content).unwrap();
    config.__finalize();
    __gen_static_rulesets(&mut rulesets, config);
}
#[cfg(test)]
mod tests {
    use super::rula::*;
    use super::*;
    #[doc = "This is generated for entanglement_swapping.rula"]
    #[tokio::test]
    async fn test_interface() {
        assert!(INTERFACES.get().is_none());
        rula::initialize_interface().await;
        let interface = INTERFACES.get().expect("Failed to get interface table");
        assert!(interface.lock().await.contains_key("qn0"));
        assert!(interface.lock().await.contains_key("qn1"));
    }
    #[tokio::test]
    async fn run_main() {
        main().await;
        assert_eq!(1, 1);
    }
}
